#' Fit and validate Generalized Additive Models
#'
#' @param data data.frame. Database with response (0,1) and predictors values.
#' @param response character. Column name with species absence-presence data (0,1).
#' @param predictors character. Vector with the column names of quantitative
#' predictor variables (i.e. continuous variables).
#' Usage predictors = c("aet", "cwd", "tmin")
#' @param predictors_f character. Vector with the column names of qualitative
#' predictor variables (i.e. ordinal or nominal variables; factors). Usage predictors_f = c("landform")
#' @param select_pred logical. Perform predictor selection. Default FALSE.
#' @param partition character. Column name with training and validation partition groups.
#' If partition = NULL, the model will be validated with the same data used for fitting.
#' @param thr character. Threshold used to get binary suitability values (i.e. 0,1). This is useful for threshold-dependent performance metrics. It is possible to use more than one threshold type. It is necessary to provide a vector for this argument. The following threshold criteria are available:
#' \itemize{
#'   \item lpt: The highest threshold at which there is no omission.
#'   \item equal_sens_spec: Threshold at which the sensitivity and specificity are equal.
#'   \item max_sens_spec: Threshold at which the sum of the sensitivity and specificity is the highest (aka threshold that maximizes the TSS).
#'   \item max_jaccard: The threshold at which the Jaccard index is the highest.
#'   \item max_sorensen: The threshold at which the Sorensen index is highest.
#'   \item max_fpb: The threshold at which FPB (F-measure on presence-background data) is highest.
#'   \item sensitivity: Threshold based on a specified sensitivity value.
#'   Usage thr = c('sensitivity', sens='0.6') or thr = c('sensitivity'). 'sens' refers to sensitivity value. If a sensitivity value is not specified, the default used is 0.9.
#'   }
#' If more than one threshold type is used they must be concatenated, e.g., thr=c('lpt', 'max_sens_spec', 'max_jaccard'), or thr=c('lpt', 'max_sens_spec', 'sensitivity', sens='0.8'), or thr=c('lpt', 'max_sens_spec', 'sensitivity'). Function will use all threshold types if none is specified.
#' @param k integer. The dimension of the basis used to represent the smooth term. Default -1 (i.e., k=10). See
#' the help in ?mgcv::s.
#'
#' @param fit_formula formula. A formula object with response and predictor
#' variables (e.g. formula(pr_ab ~ aet + ppt_jja + pH + awc + depth + landform)).
#' Note that the variables used here must be consistent with those used in
#' response, predictors, and predictors_f arguments
#'
#' @return
#'
#' A list object with:
#' \itemize{
#' \item model: A "gam" class object from mgcv package. This object can be used for predicting.
#' \item predictors: A tibble with quantitative (c column names) and qualitative (f column names) variables use for modeling.
#' \item performance: Performance metric (see \code{\link{sdm_eval}}).
#' Threshold dependent metrics are calculated based on the threshold specified in the argument.
#' \item performance_part: Performance metric for each replica and partition (see \code{\link{sdm_eval}}).
#' \item data_ens: Predicted suitability for each test partition. This database is used in \code{\link{fit_ensemble}}
#' }
#'
#' @details
#' This function fits GAM using mgvc package, with Binomial distribution family and thin plate regression spline as a smoothing basis (see ?mgvc::s).
#'
#' @seealso \code{\link{fit_gau}}, \code{\link{fit_gbm}}, \code{\link{fit_glm}},
#' \code{\link{fit_max}}, \code{\link{fit_net}}, \code{\link{fit_raf}}, and \code{\link{fit_svm}}.
#'
#' @export
#'
#' @importFrom dplyr bind_rows select all_of starts_with filter mutate tibble group_by summarise across relocate left_join
#' @importFrom mgcv gam predict.gam s
#' @importFrom stats complete.cases formula na.exclude sd
#'
#' @examples
#' \dontrun{
#' data("abies")
#'
#' # Using k-fold partition method
#' abies2 <- part_random(
#'   data = abies,
#'   pr_ab = "pr_ab",
#'   method = c(method = "kfold", folds = 10)
#' )
#' abies2
#'
#' gam_t1 <- fit_gam(
#'   data = abies2,
#'   response = "pr_ab",
#'   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
#'   predictors_f = c("landform"),
#'   select_pred = FALSE,
#'   partition = ".part",
#'   thr = "max_sens_spec"
#' )
#' gam_t1$model
#' gam_t1$predictors
#' gam_t1$performance
#' gam_t1$performance_part
#'
#' # Specifying the formula explicitly
#' require(mgcv)
#' gam_t2 <- fit_gam(
#'   data = abies2,
#'   response = "pr_ab",
#'   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
#'   predictors_f = c("landform"),
#'   select_pred = FALSE,
#'   partition = ".part",
#'   thr = "max_sens_spec",
#'   fit_formula = stats::formula(pr_ab ~ s(aet) +
#'     s(ppt_jja) +
#'     s(pH) + landform)
#' )
#'
#' gam_t2$model
#' gam_t2$predictors
#' gam_t2$performance %>% dplyr::select(ends_with("_mean"))
#'
#' # Using repeated k-fold partition method
#' abies2 <- part_random(
#'   data = abies,
#'   pr_ab = "pr_ab",
#'   method = c(method = "rep_kfold", folds = 5, replicates = 5)
#' )
#' abies2
#'
#' gam_t3 <- fit_gam(
#'   data = abies2,
#'   response = "pr_ab",
#'   predictors = c("ppt_jja", "pH", "awc"),
#'   predictors_f = c("landform"),
#'   select_pred = FALSE,
#'   partition = ".part",
#'   thr = "max_sens_spec"
#' )
#' gam_t3
#' }
fit_gam <- function(data,
                    response,
                    predictors,
                    predictors_f = NULL,
                    select_pred = FALSE,
                    partition = NULL,
                    thr = NULL,
                    fit_formula = NULL,
                    k = -1) {
  . <- model <- TPR <- IMAE <- rnames <- thr_value <- n_presences <- n_absences <- NULL
  variables <- dplyr::bind_rows(c(c = predictors, f = predictors_f))

  data <- data.frame(data)
  if (is.null(predictors_f)) {
    data <- data %>%
      dplyr::select(dplyr::all_of(response), dplyr::all_of(predictors), if (!is.null(partition)) dplyr::starts_with(partition))
    data <- data.frame(data)
  } else {
    data <- data %>%
      dplyr::select(dplyr::all_of(response), dplyr::all_of(predictors), dplyr::all_of(predictors_f), if (!is.null(partition)) dplyr::starts_with(partition))
    data <- data.frame(data)
    for (i in predictors_f) {
      data[, i] <- as.factor(data[, i])
    }
  }

  # Remove NAs
  complete_vec <- stats::complete.cases(data[, c(response, unlist(variables))])
  if (sum(!complete_vec) > 0) {
    message(sum(!complete_vec), " rows were excluded from database because NAs were found")
    data <- data %>% dplyr::filter(complete_vec)
  }
  rm(complete_vec)


  # Formula
  if (is.null(fit_formula)) {
    formula1 <-
      paste(c(
        paste("s(", predictors, paste0(", k = ", k, ")"), collapse = " + ", sep = ""),
        predictors_f
      ), collapse = " + ")
    formula1 <- stats::formula(paste(
      response, "~", formula1
    ))
  } else {
    formula1 <- fit_formula
  }

  if (!is.null(partition)) {
    message(
      "Formula used for model fitting:\n",
      Reduce(paste, deparse(formula1)) %>% gsub(paste("  ", "   ", collapse = "|"), " ", .),
      "\n"
    )
  }


  # Check amount of data and number of coefficients
  # if (k < 0) {
  #   k <- 10
  # }

  ncoef <- n_coefficients(
    data = data,
    predictors = predictors,
    predictors_f = predictors_f,
    k = k
  )

  if (!is.null(partition)) {
    if (any(n_training(data = data, partition = partition) < ncoef)) {
      message("\nModel has more coefficients than data used for training it. Try to reduce k")
      return(NULL)
    }
  }


  # Selection predictor
  if (select_pred) {
    message("Selecting predictors")

    var_selected <- mgcv::gam(formula1, data = data, family = "binomial", select = TRUE, method = "REML")
    var_selected <- summary(var_selected)$s.table %>% as.data.frame()
    names(var_selected) <- c("est", "df", "z_val", "p_val")
    var_selected <- rownames(var_selected)[var_selected$p_val <= 0.05]
    var_selected <- gsub("[)]", "", gsub("[s(]", "", var_selected))
    variables <- variables[variables %in% var_selected]
    predictors <- predictors[predictors %in% var_selected]
    predictors_f <- predictors_f[predictors_f %in% var_selected]
    if (length(predictors_f) == 0) {
      predictors_f <- NULL
    }

    formula1 <-
      paste(c(
        paste("s(", predictors, paste0(", k = ", k, ")"), collapse = " + ", sep = ""),
        predictors_f
      ), collapse = " + ")
    formula1 <- stats::formula(paste(
      response, "~", formula1
    ))

    message(
      "Formula used for model fitting:\n",
      Reduce(paste, deparse(formula1)) %>% gsub(paste("  ", "   ", collapse = "|"), " ", .),
      "\n"
    )
  }


  # Fit models
  if (is.null(partition)) {
    suppressWarnings(mod <-
      mgcv::gam(formula1,
        data = data,
        family = "binomial"
      ))

    result <- list(
      model = mod
    )
    return(result)
  } else {
    np <- ncol(data %>% dplyr::select(dplyr::starts_with(partition)))
    p_names <- names(data %>% dplyr::select(dplyr::starts_with(partition)))
    eval_partial_list <- list()
    pred_test_ens <- data %>%
      dplyr::select(dplyr::starts_with(partition)) %>%
      apply(., 2, unique) %>%
      data.frame() %>%
      as.list() %>%
      lapply(., function(x) {
        x <- stats::na.exclude(x)
        x[!(x %in% c("train-test", "test"))] %>% as.list()
      })

    for (h in 1:np) {
      message("Replica number: ", h, "/", np)

      out <- pre_tr_te(data, p_names, h)
      train <- out$train
      test <- out$test
      np2 <- out$np2
      rm(out)

      eval_partial <- as.list(rep(NA, np2))
      pred_test <- list()
      mod <- list()

      for (i in 1:np2) {
        message("Partition number: ", i, "/", np2)
        tryCatch(
          {
            suppressWarnings(mod[[i]] <-
              mgcv::gam(formula1,
                data = train[[i]],
                family = "binomial"
              ))

            # Predict for presences absences data
            if (!is.null(predictors_f)) {
              for (fi in 1:length(predictors_f)) {
                lev <- as.character(unique(mod[[i]]$xlevels[[predictors_f[fi]]]))
                lev_filt <- test[[i]][, predictors_f[fi]] %in% lev
                test[[i]] <- test[[i]][lev_filt, ]
              }
            }

            pred_test <- data.frame(
              pr_ab = test[[i]][, response],
              pred = suppressWarnings(
                mgcv::predict.gam(
                  mod[[i]],
                  newdata = test[[i]],
                  type = "response",
                  se.fit = FALSE
                )
              )
            )

            pred_test_ens[[h]][[i]] <- pred_test %>%
              dplyr::mutate(rnames = rownames(test[[i]]))

            # Validation of model
            eval <-
              sdm_eval(
                p = pred_test$pred[pred_test$pr_ab == 1],
                a = pred_test$pred[pred_test$pr_ab == 0],
                thr = thr
              )
            eval_partial[[i]] <- dplyr::tibble(model = "gam", eval)
          },
          error = function(cond) {
            message("Sorry, but it was not possible to fit the model with this data")
          }
        )
      }

      # Create final database with parameter performance
      names(eval_partial) <- 1:np2
      eval_partial <-
        eval_partial[sapply(eval_partial, function(x) !is.null(dim(x)))] %>%
        dplyr::bind_rows(., .id = "partition")
      eval_partial_list[[h]] <- eval_partial
    }

    # Stop function for those cases wh
    if (length(unique(eval_partial$partition)) < np2) {
      # opt <- options(show.error.messages = FALSE)
      # on.exit(options(opt))
      return(NULL)
    }

    eval_partial <- eval_partial_list %>%
      dplyr::bind_rows(., .id = "replica")

    eval_final <- eval_partial %>%
      dplyr::group_by(model, threshold) %>%
      dplyr::summarise(dplyr::across(
        TPR:IMAE,
        list(mean = mean, sd = stats::sd)
      ), .groups = "drop")


    # Bind data for ensemble
    pred_test_ens <-
      lapply(pred_test_ens, function(x) {
        dplyr::bind_rows(x, .id = "part")
      }) %>%
      dplyr::bind_rows(., .id = "replicates") %>%
      dplyr::tibble() %>%
      dplyr::relocate(rnames)


    # Fit final models with best settings
    suppressWarnings(mod <-
      mgcv::gam(formula1,
        data = data,
        family = "binomial"
      ))

    pred_test <- data.frame(
      pr_ab = data.frame(data)[, response],
      pred = suppressMessages(mgcv::predict.gam(
        mod,
        newdata = data,
        type = "response"
      ))
    )

    threshold <- sdm_eval(
      p = pred_test$pred[pred_test$pr_ab == 1],
      a = pred_test$pred[pred_test$pr_ab == 0],
      thr = thr
    )

    result <- list(
      model = mod,
      predictors = variables,
      performance = dplyr::left_join(eval_final, threshold[1:4], by = "threshold") %>%
        dplyr::relocate(model, threshold, thr_value, n_presences, n_absences),
      performance_part = eval_partial,
      data_ens = pred_test_ens
    )
    return(result)
  }
}
